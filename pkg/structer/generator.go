// Copyright (c) 2019 Vladimir Strackovski <vladimir.strackovski@gmail.com>
//
// This file is part of the structer project which is released under APACHE 2.0
// license. See LICENSE file or go to https://www.apache.org/licenses/LICENSE-2.0
// for full license details.

package structer

import (
    "encoding/json"
    "fmt"
    "go/format"
    "math"
    "reflect"
    "sort"
    "strconv"
    "strings"
    "unicode"
)

const (
    autoGenFileMsg = "// AUTO-GENERATED FILE\n// This file was auto-generated by structer. Do not modify!"
)

// TypeGenerator is the interface that describes the generator implementations.
type TypeGenerator interface {
    Generate(json []byte, implName, pkgName string) ([]byte, error)
}

// typeGenerator represents a generator implementation.
type typeGenerator struct {
    Config
}

// Generator is a constructor method for the typeGenerator private.
func Generator() TypeGenerator {
    return typeGenerator{Default()}
}

// Generate attempts to generate a struct definition from a JSON string provided as the first argument,
// along with names of the struct and package.
func (d typeGenerator) Generate(jsonInput []byte, structName, pkgName string) ([]byte, error) {
    return d.generate(jsonInput, structName, pkgName)
}

// generate is the method that processes the input data and  wraps the calls to the generator's private
// methods. Returns the generated struct as an array of bytes, or error on failure.
func (d typeGenerator) generate(jsonInput []byte, structName, pkgName string) ([]byte, error) {
    autoGenTxt := autoGenFileMsg
    commentTxt := "// " + structName + " is a ..."
    var resultObj interface{}
    var result map[string]interface{}

    if err := json.Unmarshal(jsonInput, &resultObj); err != nil {
        return nil, err
    }

    switch iresult := resultObj.(type) {
    case map[string]interface{}:
        result = iresult
    case []map[string]interface{}:
        if len(iresult) > 0 {
            result = iresult[0]
        } else {
            return nil, fmt.Errorf("empty array")
        }
    case []interface{}:
        src := fmt.Sprintf("%s\n\npackage %s\n\ntype %s %s\n",
            autoGenTxt,
            pkgName,
            structName,
            "[]interface{}")
        return []byte(src), nil

    default:
        return nil, fmt.Errorf("unexpected type: %T", iresult)
    }

    src := fmt.Sprintf("%s\n\npackage %s\n%s\ntype %s %s}",
        autoGenTxt,
        pkgName,
        commentTxt,
        structName,
        d.generateStruct(result, 0))
    formatted, err := format.Source([]byte(src))
    Check(err)

    return formatted, err
}

// generateStruct generates struct properties based on a map[string]interface{} structure.
func (d typeGenerator) generateStruct(obj map[string]interface{}, depth int) string {
    structure := "struct {"

    keys := make([]string, 0, len(obj))
    for key := range obj {
        keys = append(keys, key)
    }
    sort.Strings(keys)

    for _, key := range keys {
        value := obj[key]
        valueType := d.typeForValue(value)

        switch value := value.(type) {
        case []map[string]interface{}:
            valueType = "[]" + d.generateStruct(value[0], depth+1) + "}"
        case map[string]interface{}:
            valueType = d.generateStruct(value, depth+1) + "}"
        }

        fieldName := d.fmtFieldName(d.stringifyFirstChar(key))
        structure += fmt.Sprintf("\n%s %s `json:\"%s\"`",
            fieldName,
            valueType,
            key)
    }
    return structure
}

// fmtFieldName formats a string as a struct key and returns it as string.
//
// Example:
// 	fmtFieldName("foobar_id")
// Output: FoobarID
func (d typeGenerator) fmtFieldName(s string) string {
    name := d.lintFieldName(s)
    runes := []rune(name)
    for i, c := range runes {
        ok := unicode.IsLetter(c) || unicode.IsDigit(c)
        if i == 0 {
            ok = unicode.IsLetter(c)
        }
        if !ok {
            runes[i] = '_'
        }
    }
    return string(runes)
}

// lintFieldName lints the name of the given field.
func (d typeGenerator) lintFieldName(name string) string {
    if name == "_" {
        return name
    }
    allLower := true
    for _, r := range name {
        if !unicode.IsLower(r) {
            allLower = false
            break
        }
    }
    if allLower {
        runes := []rune(name)
        if u := strings.ToUpper(name); d.Config.Initialisms()[u] {
            copy(runes[0:], []rune(u))
        } else {
            runes[0] = unicode.ToUpper(runes[0])
        }
        return string(runes)
    }

    // Split camelCase at any lowercase to uppercase transition, split on underscores,
    // and scan for initialisms in each word.
    runes := []rune(name)
    w, i := 0, 0 // index of start of word, scan
    for i+1 <= len(runes) {
        eow := false // whether we hit the end of a word

        if i+1 == len(runes) {
            eow = true
        } else if runes[i+1] == '_' {
            // Shift remaining over any set of underscores.
            eow = true
            n := 1
            for i+n+1 < len(runes) && runes[i+n+1] == '_' {
                n++
            }

            // Leave max one underscore if it's between two digits.
            if i+n+1 < len(runes) && unicode.IsDigit(runes[i]) && unicode.IsDigit(runes[i+n+1]) {
                n--
            }

            copy(runes[i+1:], runes[i+n+1:])
            runes = runes[:len(runes)-n]
        } else if unicode.IsLower(runes[i]) && !unicode.IsLower(runes[i+1]) {
            eow = true
        }
        i++
        if !eow {
            continue
        }

        word := string(runes[w:i])
        if u := strings.ToUpper(word); d.Config.Initialisms()[u] {
            // All initialisms of type ASCII, replace bytes.
            copy(runes[w:], []rune(u))

        } else if strings.ToLower(word) == word {
            // All lowercase, not first word, uppercase the first character.
            runes[w] = unicode.ToUpper(runes[w])
        }
        w = i
    }
    return string(runes)
}

// typeForValue generates an appropriate struct model entry.
func (d typeGenerator) typeForValue(value interface{}) string {
    if objects, ok := value.([]interface{}); ok {
        types := make(map[reflect.Type]bool, 0)
        for _, o := range objects {
            types[reflect.TypeOf(o)] = true
        }
        if len(types) == 1 {
            return "[]" + d.typeForValue(objects[0])
        }
        return "[]interface{}"
    } else if object, ok := value.(map[string]interface{}); ok {
        return d.generateStruct(object, 0) + "}"
    } else if reflect.TypeOf(value) == nil {
        return "interface{}"
    }
    v := reflect.TypeOf(value).Name()
    if v == "float64" {
        v = d.disambiguateFloatInt(value)
    }
    return v
}

// disambiguateFloatInt checks if the number read as a float64 type, appears
// to be an integer.
func (d typeGenerator) disambiguateFloatInt(value interface{}) string {
    const epsilon = .0001
    vfloat := value.(float64)
    if math.Abs(vfloat-math.Floor(vfloat+epsilon)) < epsilon {
        var tmp = 1
        return reflect.TypeOf(tmp).Name()
    }
    return reflect.TypeOf(value).Name()
}

// stringifyFirstChar converts first character integers to strings
// corresponding to the name of the number.
func (d typeGenerator) stringifyFirstChar(str string) string {
    first := str[:1]

    i, err := strconv.ParseInt(first, 10, 8)

    if err != nil {
        return str
    }

    return d.Config.IntWordMap()[i] + "_" + str[1:]
}
